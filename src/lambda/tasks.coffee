import FS from "node:fs/promises"
import Path from "node:path"
import * as Fn from "@dashkite/joy/function"
import * as Text from "@dashkite/joy/text"
import * as Pred from "@dashkite/joy/predicate"
import * as Value from "@dashkite/joy/value"
import * as Time from "@dashkite/joy/time"

import YAML from "js-yaml"

import * as DRN from "@dashkite/drn-sky"

import {
  publishLambda
  versionLambda
  deleteLambda
} from "@dashkite/dolores/lambda"

import { 
  getRoleARN
} from "@dashkite/dolores/roles"

import {
  tail
} from "@dashkite/dolores/cloudwatch"

import { Runner } from "#helpers/runner"

run = Runner.make -> import( "./tasks" )

Lambda =

  publish: publishLambda
  version: versionLambda
  delete: deleteLambda

  isEdge: ( lambda ) ->
    lambda.event in [
      "origin-request"
      "origin-response"
      "viewer-request"
      "viewer-response"
    ]

  configure: ( lambda ) ->

    configuration = { 
      lambda.configuration...
      lambda.configurations?.default...
      ( lambda.configurations?[ mode ] )...
    }

    if Lambda.isEdge lambda
      if configuration.environment?
        console.warn "Environment variables not permitted
          for Edge Lambdas"
      configuration.environment = undefined
    else
      configuration.environment = { 
        mode
        NODE_OPTIONS: "--enable-source-maps"
        configuration.environment... 
      }

    configuration

  deploy: ( lambda ) ->
  
    mode = process.env.mode ? "development"

    try
      data = await FS.readFile ".sky/build/#{ lambda.name }.zip"
    
    if data?
      role = await getRoleARN lambda.name

      configuration = Lamda.configure lambda

      # TODO get lambda from configuration
      await Lambda.publish lambda.name, data, {
        handler: "index.handler"
        configuration...
        role
      }

      if lambda.version == true
        await Lambda.version lambda.name


Handlers =

  isPath: Pred.all [
    Text.endsWith ".coffee"
    Pred.negate Value.eq  "index.coffee"
  ]

  # TODO use dynamic imports for this
  generateIndex: ({ generate }) ->
    imports = ""
    handlers = "handlers =\n"

    root = Path.resolve generate.path
    paths = await FS.readdir root

    for path in paths when Handler.isPath path
      fname = Path.basename path, ".coffee"
      rname = Text.uncase fname
      symbol = Text.camelCase rname
      imports += "import #{ symbol } from './#{ fname }'\n"
      handlers += "  '#{ rname }': #{ symbol }\n"

    index = Path.resolve root, "index.coffee"
    await FS.writeFile index, """
      #
      # WARNING This file is automatically generated.
      #
      # DO NOT EDIT.
      #

      #{ imports }
      #{ handlers }
      export default handlers
      """

    # give it a second, in case subsequent tasks
    # need the file we just generated
    Time.sleep 1000

  verify: ({ generate, verify }) ->

    handlers = ( require Path.resolve generate?.path ? verify?.path ).default
    # TODO make this configurable?
    api = YAML.load await FS.readFile "./src/api.yaml", "utf8"
    errors = []

    for rname, resource of api.resources
      if !( _handlers = handlers[ rname ] )?
        errors.push "Missing handlers for resource [ #{ rname } ]"
      else
        for mname, method of resource.methods
          if !( handler = _handlers[ mname ] )?
            errors.push "Missing handler for resource [ #{ rname } ],
              method [ #{ mname } ]"
    
    for rname, _handlers of handlers
      if !( api.resources[ rname ]? )
        errors.push "No resource [ #{ rname } ] for handler"
      else
        for mname, handler of _handlers
          if !( api.resources[ rname ]?.methods[ mname ]? )
            errors.push "No method [ #{ mname } ] in resource
              [ #{ rname } ] for handler"

    if errors.length > 0
      for error in errors
        console.error error
      throw new Error "API handlers mismatch"

Tasks =

  # WIP
  tail: ( _ , name ) ->
    tail "/aws/lambda/#{ name }"


  deploy: ({ lambda }) ->
    Promise.all do ->
      for specifier in lambda
        Lambda.deploy specifier

  handlers: ({ lambda }) ->
    for specifier in lambda
      if specifier.generate?
        await Handlers.generateIndex specifier
    
      if specifier.generate? or specifier.verify?
        await Handlers.verify specifier

  version: ( _, name ) ->
    Lambda.version name
  
  delete: ({ lambda }) ->
    Promise.all do ->
      for { name } in lambda
        Lambda.delete name          

export default Tasks